Elm.Signal = Elm.Signal || {};
Elm.Signal.Extra = Elm.Signal.Extra || {};
Elm.Signal.Extra.make = function (_elm) {
   "use strict";
   _elm.Signal = _elm.Signal || {};
   _elm.Signal.Extra = _elm.Signal.Extra || {};
   if (_elm.Signal.Extra.values)
   return _elm.Signal.Extra.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   $moduleName = "Signal.Extra",
   $Basics = Elm.Basics.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var combine = A2($List.foldr,
   $Signal.map2(F2(function (x,y) {
      return A2($List._op["::"],
      x,
      y);
   })),
   $Signal.constant(_L.fromArray([])));
   var mapMany = F2(function (f,
   l) {
      return A2($Signal._op["<~"],
      f,
      combine(l));
   });
   var applyMany = F2(function (fs,
   l) {
      return A2($Signal._op["~"],
      fs,
      combine(l));
   });
   var keepIf = $Signal.filter;
   var filter = function (initial) {
      return function ($) {
         return $Signal.map(function (mx) {
            return function () {
               var _raw = mx,
               $ = _raw.ctor === "Just" ? _raw : _U.badCase($moduleName,
               "on line 267, column 33 to 35"),
               x = $._0;
               return x;
            }();
         })(A2(keepIf,
         function (mx) {
            return function () {
               switch (mx.ctor)
               {case "Nothing": return false;}
               return true;
            }();
         },
         $Maybe.Just(initial))($));
      };
   };
   var filterMap = F2(function (f,
   initial) {
      return function ($) {
         return filter(initial)($Signal.map(f)($));
      };
   });
   var runBuffer$ = F3(function (l,
   n,
   input) {
      return function () {
         var f = F2(function (inp,
         prev) {
            return function () {
               var l = $List.length(prev);
               return _U.cmp(l,
               n) < 0 ? A2($Basics._op["++"],
               prev,
               _L.fromArray([inp])) : A2($Basics._op["++"],
               A2($List.drop,l - n + 1,prev),
               _L.fromArray([inp]));
            }();
         });
         return A3($Signal.foldp,
         f,
         l,
         input);
      }();
   });
   var runBuffer = runBuffer$(_L.fromArray([]));
   var foldps = F3(function (f,
   bs,
   aS) {
      return A2($Signal._op["<~"],
      $Basics.fst,
      A3($Signal.foldp,
      F2(function (a,_v1) {
         return function () {
            switch (_v1.ctor)
            {case "_Tuple2": return A2(f,
                 a,
                 _v1._1);}
            _U.badCase($moduleName,
            "on line 120, column 29 to 34");
         }();
      }),
      bs,
      aS));
   });
   var delayRound = F2(function (b,
   bS) {
      return A3(foldps,
      F2(function ($new,old) {
         return {ctor: "_Tuple2"
                ,_0: old
                ,_1: $new};
      }),
      {ctor: "_Tuple2",_0: b,_1: b},
      bS);
   });
   var filterFold = F2(function (f,
   initial) {
      return function () {
         var f$ = F2(function (a,s) {
            return function () {
               var res = A2(f,a,s);
               return {ctor: "_Tuple2"
                      ,_0: res
                      ,_1: A2($Maybe.withDefault,
                      s,
                      res)};
            }();
         });
         return function ($) {
            return filter(initial)(A2(foldps,
            f$,
            {ctor: "_Tuple2"
            ,_0: $Maybe.Just(initial)
            ,_1: initial})($));
         };
      }();
   });
   var initSignal = function (s) {
      return A2($Signal.sampleOn,
      $Signal.constant({ctor: "_Tuple0"}),
      s);
   };
   var switchHelper = F4(function (filter,
   b,
   l,
   r) {
      return function () {
         var fromJust = function (_v5) {
            return function () {
               switch (_v5.ctor)
               {case "Just": return _v5._0;}
               _U.badCase($moduleName,
               "on line 211, column 25 to 26");
            }();
         };
         var lAndR = A2($Signal.merge,
         A3(filter,
         b,
         $Maybe.Nothing,
         A2($Signal._op["<~"],
         $Maybe.Just,
         l)),
         A3(filter,
         A2($Signal._op["<~"],
         $Basics.not,
         b),
         $Maybe.Nothing,
         A2($Signal._op["<~"],
         $Maybe.Just,
         r)));
         var base = A2($Signal._op["~"],
         A2($Signal._op["~"],
         A2($Signal._op["<~"],
         F3(function (bi,li,ri) {
            return $Maybe.Just(bi ? li : ri);
         }),
         initSignal(b)),
         initSignal(l)),
         initSignal(r));
         return A2($Signal._op["<~"],
         fromJust,
         A2($Signal.merge,base,lAndR));
      }();
   });
   var unzip4 = function (pairS) {
      return {ctor: "_Tuple4"
             ,_0: A2($Signal._op["<~"],
             function (_v8) {
                return function () {
                   switch (_v8.ctor)
                   {case "_Tuple4": return _v8._0;}
                   _U.badCase($moduleName,
                   "on line 80, column 19 to 20");
                }();
             },
             pairS)
             ,_1: A2($Signal._op["<~"],
             function (_v14) {
                return function () {
                   switch (_v14.ctor)
                   {case "_Tuple4":
                      return _v14._1;}
                   _U.badCase($moduleName,
                   "on line 80, column 47 to 48");
                }();
             },
             pairS)
             ,_2: A2($Signal._op["<~"],
             function (_v20) {
                return function () {
                   switch (_v20.ctor)
                   {case "_Tuple4":
                      return _v20._2;}
                   _U.badCase($moduleName,
                   "on line 80, column 75 to 76");
                }();
             },
             pairS)
             ,_3: A2($Signal._op["<~"],
             function (_v26) {
                return function () {
                   switch (_v26.ctor)
                   {case "_Tuple4":
                      return _v26._3;}
                   _U.badCase($moduleName,
                   "on line 80, column 103 to 104");
                }();
             },
             pairS)};
   };
   var unzip3 = function (pairS) {
      return {ctor: "_Tuple3"
             ,_0: A2($Signal._op["<~"],
             function (_v32) {
                return function () {
                   switch (_v32.ctor)
                   {case "_Tuple3":
                      return _v32._0;}
                   _U.badCase($moduleName,
                   "on line 74, column 17 to 18");
                }();
             },
             pairS)
             ,_1: A2($Signal._op["<~"],
             function (_v37) {
                return function () {
                   switch (_v37.ctor)
                   {case "_Tuple3":
                      return _v37._1;}
                   _U.badCase($moduleName,
                   "on line 74, column 43 to 44");
                }();
             },
             pairS)
             ,_2: A2($Signal._op["<~"],
             function (_v42) {
                return function () {
                   switch (_v42.ctor)
                   {case "_Tuple3":
                      return _v42._2;}
                   _U.badCase($moduleName,
                   "on line 74, column 69 to 70");
                }();
             },
             pairS)};
   };
   var unzip = function (pairS) {
      return {ctor: "_Tuple2"
             ,_0: A2($Signal._op["<~"],
             $Basics.fst,
             pairS)
             ,_1: A2($Signal._op["<~"],
             $Basics.snd,
             pairS)};
   };
   var zip4 = $Signal.map4(F4(function (v0,
   v1,
   v2,
   v3) {
      return {ctor: "_Tuple4"
             ,_0: v0
             ,_1: v1
             ,_2: v2
             ,_3: v3};
   }));
   var zip3 = $Signal.map3(F3(function (v0,
   v1,
   v2) {
      return {ctor: "_Tuple3"
             ,_0: v0
             ,_1: v1
             ,_2: v2};
   }));
   var zip = $Signal.map2(F2(function (v0,
   v1) {
      return {ctor: "_Tuple2"
             ,_0: v0
             ,_1: v1};
   }));
   var keepWhen = F3(function (boolSig,
   a,
   aSig) {
      return $Signal.map($Basics.snd)(A2(keepIf,
      $Basics.fst,
      {ctor: "_Tuple2"
      ,_0: true
      ,_1: a})($Signal.sampleOn(aSig)(A2(zip,
      boolSig,
      aSig))));
   });
   var switchWhen = F3(function (b,
   l,
   r) {
      return A4(switchHelper,
      keepWhen,
      b,
      l,
      r);
   });
   var sampleWhen = F3(function (bs,
   def,
   sig) {
      return $Signal.map($Basics.snd)(A2(keepIf,
      $Basics.fst,
      {ctor: "_Tuple2"
      ,_0: true
      ,_1: def})(A2(zip,bs,sig)));
   });
   var switchSample = F3(function (b,
   l,
   r) {
      return A4(switchHelper,
      sampleWhen,
      b,
      l,
      r);
   });
   var keepThen = F3(function (choice,
   base,
   signal) {
      return A2(switchSample,
      choice,
      signal)($Signal.constant(base));
   });
   _op["~>"] = $Basics.flip($Signal.map);
   var foldp$ = F3(function (fun,
   initFun,
   input) {
      return function () {
         var fromJust = function (_v47) {
            return function () {
               switch (_v47.ctor)
               {case "Just": return _v47._0;}
               _U.badCase($moduleName,
               "on line 107, column 25 to 26");
            }();
         };
         var fun$ = F2(function (_v50,
         mb) {
            return function () {
               switch (_v50.ctor)
               {case "_Tuple2":
                  return $Maybe.Just(fun(_v50._0)(A2($Maybe.withDefault,
                    _v50._1,
                    mb)));}
               _U.badCase($moduleName,
               "between lines 104 and 105");
            }();
         });
         var initial = A2(_op["~>"],
         initSignal(input),
         initFun);
         var rest = A3($Signal.foldp,
         fun$,
         $Maybe.Nothing,
         A2(zip,input,initial));
         return A2($Signal._op["<~"],
         fromJust,
         A2($Signal.merge,
         A2($Signal._op["<~"],
         $Maybe.Just,
         initial),
         rest));
      }();
   });
   var foldps$ = F3(function (f,
   iF,
   aS) {
      return A2($Signal._op["<~"],
      $Basics.fst,
      A3(foldp$,
      F2(function (a,_v54) {
         return function () {
            switch (_v54.ctor)
            {case "_Tuple2": return A2(f,
                 a,
                 _v54._1);}
            _U.badCase($moduleName,
            "on line 126, column 46 to 51");
         }();
      }),
      iF,
      aS));
   });
   var foldpWith = F4(function (unpack,
   step,
   init,
   input) {
      return function () {
         var step$ = F2(function (a,
         _v58) {
            return function () {
               switch (_v58.ctor)
               {case "_Tuple2":
                  return unpack(A2(step,
                    a,
                    _v58._1));}
               _U.badCase($moduleName,
               "on line 140, column 7 to 25");
            }();
         });
         return A2(_op["~>"],
         A3($Signal.foldp,
         step$,
         init,
         input),
         $Basics.fst);
      }();
   });
   var keepWhenI = F2(function (fs,
   s) {
      return function () {
         var fromJust = function (_v62) {
            return function () {
               switch (_v62.ctor)
               {case "Just": return _v62._0;}
               _U.badCase($moduleName,
               "on line 257, column 25 to 26");
            }();
         };
         return A2(_op["~>"],
         A3(keepWhen,
         A2($Signal.merge,
         $Signal.constant(true),
         fs),
         $Maybe.Nothing,
         A2($Signal._op["<~"],
         $Maybe.Just,
         s)),
         fromJust);
      }();
   });
   var fairMerge = F3(function (resolve,
   left,
   right) {
      return function () {
         var merged = A2($Signal.merge,
         left,
         right);
         var boolRight = A2($Signal._op["<~"],
         $Basics.always(false),
         right);
         var boolLeft = A2($Signal._op["<~"],
         $Basics.always(true),
         left);
         var bothUpdated = A2($Signal._op["~"],
         A2($Signal._op["<~"],
         F2(function (x,y) {
            return !_U.eq(x,y);
         }),
         A2($Signal.merge,
         boolLeft,
         boolRight)),
         A2($Signal.merge,
         boolRight,
         boolLeft));
         var keep = keepWhenI(bothUpdated);
         var resolved = A2($Signal._op["~"],
         A2($Signal._op["<~"],
         resolve,
         keep(left)),
         keep(right));
         return $Signal.merge(resolved)(merged);
      }();
   });
   _elm.Signal.Extra.values = {_op: _op
                              ,zip: zip
                              ,zip3: zip3
                              ,zip4: zip4
                              ,unzip: unzip
                              ,unzip3: unzip3
                              ,unzip4: unzip4
                              ,foldp$: foldp$
                              ,foldps: foldps
                              ,foldps$: foldps$
                              ,runBuffer: runBuffer
                              ,runBuffer$: runBuffer$
                              ,delayRound: delayRound
                              ,keepIf: keepIf
                              ,keepWhen: keepWhen
                              ,sampleWhen: sampleWhen
                              ,switchWhen: switchWhen
                              ,keepWhenI: keepWhenI
                              ,switchSample: switchSample
                              ,keepThen: keepThen
                              ,filter: filter
                              ,filterMap: filterMap
                              ,filterFold: filterFold
                              ,fairMerge: fairMerge
                              ,combine: combine
                              ,mapMany: mapMany
                              ,applyMany: applyMany};
   return _elm.Signal.Extra.values;
};