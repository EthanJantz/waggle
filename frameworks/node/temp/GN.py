"""
4 threads:
1.	main_thread (object of main_class): Spawns other threads and processes any messages intended for itself

2.	sensor_controller (object of sensor_controller_class): Handles all communication with sensors

3.	buffer_mngr (object of buffer_mngr_class): Sends msgs from main_thread and sensor_controller threads to the external_communicator thread 
    and dispatches received_external_msg msgs to appropriate threads by examining the msg_type or if needed then seq_no

4.	external_communicator (object of external_communicator_class): Handles the sending and receiving of messages 


Formats:
1.	format of the msg received/sent from/to the NC will be: seq_no/msg_type/inst_id/....
        1a. GN Registration format: Header_Level1/mac_address/[list of version nos]/[sensor_id1, bidirectional, time_interval, time_interval_settable, [reading_name1, param_name1, param_val], [reading_name1, param_name2, param_val]],..],
            [sensor_id2, bidirectional, start_time, time_interval, time_interval_settable, [reading_name1, param_name1, param_val], [reading_name1, param_name2, param_val]], [], [],..]
        1b. GN Registration ACK:  seq_no/0/inst_id/ACK   
        2a. Data format: seq_no/1/inst_id/sensor_id/reading_time/[reading_name, reading_type, reading_val, reading_unit, node_id], [reading_name, reading_type, reading_val, reading_unit, node_id],...
        2b. Data ACK Format:  seq_no/1/inst_id/sensor_id/reading_time/ACK
        3a. Command Format: seq_no/2/inst_id/command/args
        3b. Command Reply Format: seq_no/3/inst_id/command_reply in string form
        
2. 	format of the msg received/sent from/to NC, present in communicator's buffer will be: internal_msg_header("send_external_msg"/"received_external_msg")/seq_no/msg_type/inst_id/....

3. 	format of any internal msg generated by a thread to communicate with another thread will be: 
    internal_msg_header("received_internal_msg")/seq_no/thread_name/cmd/cmd_reply or "received_internal_msg")/internal_seq_no/thread_name/cmd
    
4. 	format of storage of sensors' information on GN side in hierarchical dictionary:
    {
    afk000(sensor_id):
                        {	
                            temp1 (reading_name1):	{
                                                    reading_val: [],
                                                    precision: [val, set_bit]
                                                    unit: [val]
                                                    type: [val]
                                                    }
                            temp2(reading_name2):		{
                            
                                                    }
                            start_time: 00:00:00 (time)
                            time_interval: n secs
                            time_interval_settable: (0/1)
                            bidirectional: (0/1)
                            reading_time: []
                        }
    idt111:
                        {
                            light:					{
                                                    reading_val: [],
                                                    precision: [val, set_bit]
                                                    unit: [val]
                                                    type: [val]
                                                    }
                            start_time: 00:00:00 (time)
                            time interval: n secs
                            time_interval_settable: (0/1)
                            bidirectional: val (0/1)
                            reading_time: []
                        }
    :
    :
    }

5.	format of initial information like params etc. received from sensors: 
    [
    [sensor_id1, start_time, time_interval, bidirectional, time_interval_settable, 
    [reading_name1, [param_name1, param_val], .., [param_nameN, param_val]], .., [reading_nameN, [param_name1, param_val], .., [param_nameN, param_val]]], 

    [sensor_id2, start_time, time_interval, bidirectional, time_interval_settable, 
    [reading_name1, [param_name1, param_val], .., [param_nameN, param_val]], .., [reading_nameN, [param_name1, param_val], .., [param_nameN, param_val]]], 
    ..
    ]
    
6.	format of periodic readings received from sensor by passing sensor_id: reading_time, [[reading_name1, reading_val], [reading_name2, reading_val], [reading_name3, reading_val]..]

7. 	format of set parameters sent to the sensors' through set_params() function will be:
    1. For setting params common to all readings of the sensor:
        [
        [sensor_id1, [param_name1, param_val], .., [param_nameN, param_val]], 
        [sensor_id2, [param_name1, param_val], .., [param_nameN, param_val]], 
        .., 
        ]
    2. For setting params specific to each reading of the sensor:
        [
        [sensor_id1, [reading_name1, [param_name1, param_val], .., [param_nameN, param_val]], [reading_name2, [param_name1, param_val],.., [param_nameN, param_val]], .., [reading_nameN,..],..]
        [sensor_id2, [reading_name1, [param_name1, param_val], .., [param_nameN, param_val]], [reading_name2, [param_name1, param_val], .., [param_nameN, param_val]], .., [reading_nameN,..],..]
        ..
        ]
        

8. 	format of unacknowledged_msg_handler_info = [seq_no/sensor_id, expiration_time, msg, handler_name] 	
"""
"""
TODO: 
Put the section from generating seq no to inserting in the buffer within lock
buffer_mngr should check whenever a new msg is received from NC whether it is equal to the expected_seq_no_from_nc 



"""


import sys
import asyncore                                                                                                                 # required for aynchronous sockets
import asynchat                                                                                                                 # required for aynchronous sockets
import socket                                                                                                                   # required for sockets
import logging                                                                                                                  # used by logging module to log debug messages
import threading                                                                                                                # used for multithreading
import Queue                                                                                                                    # to implement thread safe queues for Inter thread communication
import time
import datetime
from external_communicator_class import external_communicator_class
from collections import namedtuple
from collections import defaultdict                                                                                             # used to store sensors information in the hierarchical dictionary provided by this module
#from sensor_data import get_sensors_info
#import msg_parse 
import waggle.common.messaging2
from datetime import timedelta
from common_thread_functions import add_to_sorted_output_buffer, add_to_thread_buffer




sensor_controller = ''                                               # global object of sensor_controller_class which manages all sensors related messages
buffer_mngr = ''                                                     # global object of buffer_mngr_class which manages the buffer for sent and received messages
sensors_info_dict = defaultdict(lambda: defaultdict(list))			   # global structure containing all sensor related information
unacknowledged_msg_thread_mapping = {}								   # global structure containing (seq_no, thread_name) of all unacknowledged msgs sent to NC/GNs 
last_seq_no_to_nc = 0												   # keeps track of the seq_no of the new msg which will be sent to NC. For cmd or data replies the msg no of the acks will be same as the corresponding original msgs. 
expected_seq_no_from_nc = 0                                          # to keep track of the msgs from NC
internal_seq_no = 0											   		   # keeps track the next seq_no of the msg which will be sent amongst threads. For cmd replies the msg no of the acks will be same as the corresponding original msgs.
nc_port = 8000														   # port at which Gn can contact NC
nc_ip = "127.0.0.1"													   # NC's ip address




'''
    DELIMITERS[i]:
    [0]: used only for string message type
    [1]: used to separage different msg in a string
    [2]: for data fields in a msg
    [3]: for sub fields in a data field

    '''
global DELIMITERS
DELIMITERS = [' [0] ',' [1] ',' [2] ',' [3] ',' [4] ',' [5] '] 

# Message retrieved/stored in the buffer_mngr's buffer will use this tuple
buffered_msg = namedtuple('buffered_msg', ['internal_msg_header', 'msg'])

# Indicates the level of msgs that should be displayed 
logging_level = 2

# used for logging msgs from each thread tagged by the respective thread_name
logging.basicConfig(level=logging.NOTSET,format='%(name)s: %(message)s',)
    
# To signal successful registration
start_communication_with_nc_event = threading.Event() 

# Function: Sets the logging level of the messages based on the value of the variable: logging_level
def set_logging_level(context_name):
    logger = logging.getLogger(context_name)
        
    if logging_level == 0:
        logger.setLevel(0)
    elif logging_level == 1:
        logger.setLevel(10)
    elif logging_level == 2:
        logger.setLevel(20)
    elif logging_level == 3:
        logger.setLevel(30)
    elif logging_level == 4:
        logger.setLevel(40)
    elif logging_level == 5:
        logger.setLevel(50)
        
    return logger


# Stores sensors' information like parameters and their attributes and start_time, time_interval between two readings etc. in hierarchical dictionary structure
# it stores None in "reading_val" and "reading_time" attributes as the sensors have not been started. "reading_time" keeps track of the time when a new reading is taken.
# Arg sensors_info has format: [[sensor_id, start time, time_interval, bidirectional, reading_names[], param_names[], param_val[]],[sensor_id, start time, time_interval, bidirectional, reading_names[], param_names[], param_val[]]..]
# TODO: Ask params obtained when sensors are not started?
def create_sensors_info_dict(sensors_info):
    time_interval = 10                                          # in secs
    sensors_info = msg_parse.parse_multiple_sensor_msgs(sensors_info) 
    # self.logger.debug (sensors_info)
    # insert the info in sensors_info_dict
    for single_sensor_params in sensors_info:
        single_sensor_info = {}
        single_sensor_info["reading_time"] = None
        single_sensor_info["start_time"] = single_sensor_params[1]
        single_sensor_info["time_interval"] = time_interval
        # extract and insert params one by one
        for reading_name, reading_unit, reading_val, reading_type, node_id in \
        zip(single_sensor_params[2], single_sensor_params[3], single_sensor_params[4], single_sensor_params[5], single_sensor_params[6]):
            params_info = {}
            params_info["reading_val"] = reading_val																					
            params_info["type"] = reading_type
            params_info["unit"] = reading_unit
            params_info["node_id"] = node_id
            # here other params entries will also be added in future like for temp "high", "crit"
            single_sensor_info[reading_name] = params_info																			
        sensors_info_dict[str(single_sensor_params[0])] = single_sensor_info
        time_interval += 10
    #self.logger.debug ((sensors_info_dict))
    
    

# Updates the sensors_info_dict (hierarchical dict) with the new values            
# Updation can be of 2nd level keys' values like start_time, time interval, or of 3rd level keys' values like parameters' values 
# If updation to 2nd level keys' values is required, the arg sensors_info has format: [[sensor_id, param_names[], param_val[]],[sensor_id, param_names[], param_val[]]..]
# If updation to 3rd level keys' values is required, the arg sensors_info has format: [[sensor_id, reading_time, reading_names[], param_names[], param_val[]],[sensor_id, reading_time, reading_names[], param_names[], param_val[]]..]
def update_sensors_info_dict(update_dict_level, sensors_info):
    sensors_info = msg_parse.parse_multiple_sensor_msgs(sensors_info) 
    # If updation to common paramters is needed like start_time, time_interval etc.
    if update_dict_level == 1:
        for single_sensor_info in sensors_info:
            sensor_id = str(single_sensor_info[0])
            for param_name, param_val \
            in zip(single_sensor_info[1], single_sensor_info[2]):
                sensors_info_dict[sensor_id][param_name] = param_val
    elif update_dict_level == 2:
        for single_sensor_info in sensors_info:
            sensor_id = str(single_sensor_info[0]) 
            
            sensors_info_dict[sensor_id]["reading_time"] = single_sensor_info[1]
            for reading_name, param_name, param_val \
            in zip(single_sensor_info[2], single_sensor_info[3], single_sensor_info[4]):
                self.logger.debug ("readingname:"+str(reading_name))
                sensors_info_dict[sensor_id][reading_name][param_name] = param_val
# self.logger.debug "sensors_info"+str(sensors_info_dict)
# self.logger.debug ("values updated")
    
    
    
"""
def sensor_data_ready_handler(signum, frame):
        msg  = "Message received from idt000: my data"
        msg = add_header(msg, "internal")
        sensor_controller.q.put(msg)
"""



# Adds internal header like "send_external_msg"/"received_external_msg"/"received_internal_msg" to the msg
def add_internal_msg_header(msg, header):
    header_and_msg = header + "/" + msg
    return header_and_msg

    
    
# Returns the internal header like "send_external_msg"/"received_external_msg"/"received_internal_msg" which is used to distinguish messages present in the buffers inside the GN 
def extract_internal_msg_header(msg):
    header_and_msg = msg.split("/")
    return header_and_msg[0]

    
    
# Generates last_seq_no_to_nc by incrementing the global last_seq_no_to_nc by 1
# TODO: Implement the mapping of local seq_no to global seq_no
def gen_next_seq_no_to_nc():
    global last_seq_no_to_nc
    last_seq_no_to_nc += 1
    return last_seq_no_to_nc
    
    
    
# Adds seq_no either internal or seq_no in the front of the msg  
def add_seq_no(msg, seq_no):
    return (str(seq_no)+"*"+msg)

    
    
# Returns the seq_no present in the beginning of the msg
def extract_seq_no(msg):
    msg = msg.split('*')
    return int(msg[0])

    
    
# msg is in string form and msg_type is in int
def add_msg_type(msg, msg_type):
    array = [msg, msg_type]
    # Calls Tony's function to convert to string by adding msg_type in front of the msg and separating both with delimiter
    convertTostr(array,0)                                                                               							# 0 is the index in DELIMITERS array 

    
    
# Returns only the msg part 
def remove_internal_msg_header(msg):
    msg = msg.split("/")
    return msg[1]

    
    
"""
TODO: Remove this later on if evertyhing works
def add_to_output_buffer(seq_no, unacknowledged_msg_handler_info, output_buffer, thread_inst):
    add_to_thread_buffer(output_buffer, ms)
    logger.debug ("events in "+thread_inst.name+"'s event_buffer:\n"+str(output_buffer))

def del_event(seq_no, event_buffer):
    pass

"""



# Returns the current time in string form
def get_current_time():
    return time.strftime ('%Y.%m.%d.%H.%M.%S')

    
    
# TODO: Make addition of any time magnitude possible, curently only supports adding secs           
def add_to_current_time(seconds):
    logger.debug (seconds)
    d1 = datetime.datetime.now() + datetime.timedelta(seconds = seconds)
    #time1 = datetime.datetime.strptime(time1, "%Y.%m.%d.%H.%M.%S")
    #return (time1 + datetime.timedelta(0, time2))
    # d1 = time.time() + seconds
    return d1

    
    
# TODO: Make addition of any time magnitude possible, curently only supports adding secs           
def add_time(time1, time2):
    logger.debug (time1)
    d1 = datetime.datetime.now() + datetime.timedelta(time2)
    #time1 = datetime.datetime.strptime(time1, "%Y.%m.%d.%H.%M.%S")
    #return (time1 + datetime.timedelta(0, time2))
    return d1

    
    
# Makes a new entry of seq_no:thread_name mapping
def add_to_unacknowledged_msg_thread_mapping(seq_no, thread_inst):
    unacknowledged_msg_thread_mapping[seq_no] = thread_inst

    
    
"""    
def add_headers(string_msg, seq_no):
    string_msg = add_seq_no(string_msg, seq_no)
    string_msg = add_header(string_msg, "send_external_msg")
    return string_msg  

def add_to_buffers(seq_no, unacknowledged_msg_handler_info, event_buffer, name, thread_inst):
    add_to_output_buffer(seq_no, unacknowledged_msg_handler_info, event_buffer, name)
    add_to_unacknowledged_msg_thread_mapping(seq_no, thread_inst)
"""    




        
        
# buffer_mngr (object of buffer_mngr_class): Sends msgs from main_thread and sensor_controller threads to the external_communicator thread
# and dispatches msgs from NC/GNs to appropriate threads by examining the msg_type or if needed then seq_no
class buffer_mngr_class(threading.Thread):
    
    logger = set_logging_level("buffer_mngr_class")
    
    def __init__(self, thread_name, nc_ip, nc_port):
        
        threading.Thread.__init__(self)
        # self.threadID = threadID
        self.thread_name = thread_name					# used for tagging the msgs related to this thread
        self.daemon = True								# runs this thread in background 
        self.msg_buffer = Queue.Queue()				# stores all incoming as well as outgoing msgs coming from sensor_controller_class, main_class, external_communicator_class and also any internal msg intended for buffer_mngr_class
        self.nc_ip = nc_ip								# to pass to the external_communicator_class
        self.nc_port = nc_port							# port at which NC listens for incoming requests, to be passed to the external_communicator_class 
        self.sorted_output_msg_buffer = []                                                              
        self.logger.debug("Thread "+self.thread_name+" Initialized.")
        
        
    def run(self):
        global main_thread										           # to access its input_buffer to send any internal msg
        global sensor_controller        							   # to access its input_buffer to send any internal msg
        self.logger.debug("Starting " + self.thread_name)
        # Creates new thread
        external_communicator = external_communicator_class("external_communicator", self.nc_ip, self.nc_port) 
        # Starts new Thread
        external_communicator.start()
        
        # Waits on the msg_buffer till a msg is received       
        while True:
            self.logger.debug ("buffer_mngr thread looping")
            #time.sleep(20)
            
            item = self.msg_buffer.get()
            # self.logger.debug (item)
            # internal_msg_header can be:
            #    1. send
            #    2. received_external_msg
            #    3. received_internal_msg
            internal_msg_header = item.internal_msg_header
            
            # Pushes all msgs to be sent to NC/GNs to external_communicator's output_buffer by extracting original_msg from msg = "send_external_msg"+original_msg
            if internal_msg_header == "send_external_msg":
                # msg_type = extract_msg_field(msg, 0, 2)				# extracts the element with index 2 after separating using delimiter level 0
                # extract and store the seq_no, handler_info, msg 
                
                self.logger.debug("Msg to NCR leaving buffer_mngr's buffer: "+str(item.msg))
                external_communicator.push(item.msg)																						# pushes to the output buffer of external_communicator_class
                
            # Pushes all received_external_msg msgs to either main_thread's buffer or sensor_controller's buffer
            elif internal_msg_header == "received_external_msg":
                # extract msg_type
                msg = item.msg
                msg_type = msg.msg_type
                # cmd
                if msg_type == 1:
                    dispatch_cmd(msg)                                                       # after decoding the command it dispatches it to the appropriate thread
                # reply: can be 1st or 2nd level ACK 
                elif msg_type == 2:
                    # based on reply_id it gets the corresponding thread instance and sends to its input_buffer
                    thread_inst = self.get_thread_inst(msg.reply_id)
                    thread_inst.input_buffer.put(item)
            # self.logger.debug("Msg from NCR: "+str(msg))
                    
            # Processes internal msg
            elif internal_msg_header == "received_internal_msg":
                pass

            self.msg_buffer.task_done()
    
    
    def reg_msg_handler(self, cmd, reply):
        self.logger.debug("Registration msg handler called")
        if reply:
            reply_content = reply.payload
            if reply_content == "Registration Done":
                start_communication_with_nc_event.set()
                self.create_config_file()
            elif reply_content == "ACK":                                                                        # immediate ACK is obtained
                # insert another packet which times out if final ACK = "Action taken" is not obtained
                expiration_time = add_to_current_time(60)                                                       # no of seconds to be added to the current time to set the timeout 
                unacknowledged_msg_handler_info = [seq_no, expiration_time, cmd, self.reg_msg_handler_no]       # contains seq_no, expiration_time, registration msg, handler no corresponding to the handler which will be called when this msg times out or acknowledged
                add_to_sorted_output_buffer(self.sorted_output_msg_buffer, unacknowledged_msg_handler_info)     # adds unacknowledged_msg_handler_info to its own sorted_output_msg_buffer to keep track whether the msg is received or not through acknowledgement 
                self.logger.debug("1st ACK obtained and waiting for 2nd ACK")
        else:
            # TODO: handle failure
            self.logger.debug("Registration timeout: ABORTING................................................................................................................................................")
            sys.exit(-1)
     
    
    # based on seq_no it fetches the thread_inst from the unacknowledged_msg_thread_mapping dict 
    def get_thread_inst(self, seq_no):
        return unacknowledged_msg_thread_mapping[seq_no]


        
        
# sensor_request_handler (object of sensor_controller_class): Processes msgs related to sensors
class sensor_request_handler_class(threading.Thread):
    
    logger = set_logging_level("sensor_controller_class")
    # ping_and_resend = '2'
    
    def __init__(self, thread_name):
        
        threading.Thread.__init__(self)
        # self.threadID = threadID
        self.thread_name = thread_name                                   # used by logging module for printing messages related to this thread
        self.daemon = True
        self.input_buffer = Queue.Queue()                                # stores messages sent by buffer_mngr_class, main_class
        
        self.sensor_data_ready_time_sorted_list = []                                                              
        
        self.initialize_sensor_data_ready_time_sorted_list()             # initialize the sorted_output_msg_buffer by inserting msgs to which serve as a notification when new readings are available from the sensors  
        self.logger.debug("Thread "+self.thread_name+" Initialized.")


    def initialize_sensor_data_ready_time_sorted_list(self):
        pass
        



# sensor_controller (object of sensor_controller_class): Processes msgs related to sensors
class sensor_controller_class(threading.Thread):
    
    logger = set_logging_level("sensor_controller_class")
    # ping_and_resend = '2'
    
    def __init__(self, thread_name):
        
        threading.Thread.__init__(self)
        # self.threadID = threadID
        self.thread_name = thread_name																# used by logging module for printing messages related to this thread
        self.daemon = True
        self.input_buffer = Queue.Queue()															# stores messages sent by buffer_mngr_class, main_class
        
        # TODO: partition the buffer into two
        # stores messages sent to any node/communicator/main threads which are unacknowledged and also any events like "sensor data ready" which should occur periodically
        # Contains msg_handler_info for each such msg and the format of that is: [seq_no, expiration_time, msg, handler_name]
        # seq_no for:
        # 	1.	unacknowledged sent msgs: seq_no / id of original command received from NC/GNs
        #	2.	msgs to signal specific events: None or sensor_[here sensor_id goes]
        # expiration_time for: 
        #	1.	msgs sent to NC/GNs: sent_time+wait_time
        #	2.	msgs to signal specific events like "sensor data ready" etc.: last_reading_time + time_interval
        # msg = string (Ex in case of event type msgs: "data ready/" or "GN_list/reading_name" or "reading_GNs/reading_name/list of GNs" or "GN_readings/GN_id")
        # handler_name: function to be called when the msg expires or is acknowledged
        self.sorted_output_msg_buffer = []																
        
        # handler_vector_table stores the mapping of the handler_no and handler, handler_no will be used to get function name using handler_no when the expiration_time of any msg (like "sensor data ready") in sorted output msg buffer is reached 
        # or unacknowledged msg times out or is acknowledged
        self.handler_vector_table = {}
        
        self.initialize_sorted_output_msg_buffer()				# initialize the sorted_output_msg_buffer by inserting msgs to which serve as a notification when new readings are available from the sensors  
        self.initialize_handler_vector_table()					# inserts the handler_no and corresponding handlers' names mappings
        self.logger.debug("Thread "+self.thread_name+" Initialized.")
    
    
    
    # Function: Reads the values from the specified sensor and sends them to the NC by adding to the communicator's buffer
    def read_and_send_sensor_data(self, *args, **kwargs):
        sensors_info = get_sensors_info()
        update_sensors_info(sensors_info)														   # updates sensors_info_dict
        self.logger.debug("Data read from the sensors and updated.....................")
        string_msg = prepare_msg(sensors_info)													   # prepares msg in string form using sesnors information passed to it 
        string_msg = add_internal_msg_header(string_msg, "send_external_msg")                                # adds header "send_external_msg" in front of the registration message and returns whole message in string form by adding delimiter
        unacknowledged_msg_handler_info = [1, time, string_msg, 4, ping_and_resend]
        self.input_buffer.put(string_msg)           
    
        # all these steps will be moved to sensor_controller's run function
        # use semaphores/lock
        seq_no = gen_next_seq_no_to_nc()
        # unlock
        string_msg = add_msg_type(string_msg, msg_type)                                         # adds header msg_type (can be 0/1/2/3) in front of the registration message and returns whole message in string form by adding delimiter
        string_msg = add_seq_no(string_msg, seq_no)                                    # adds header seq_no in front of the registration message and returns whole message in string form by adding delimiter
        time = get_current_time()
        add_to_unacknowledged_msg_thread_mapping(seq_no, self)                         # adds (seq_no, self) to the unacknowledged_msg_thread_mapping to inform the communicator about the unacknowledged msg
        add_to_thread_buffer(self.sorted_output_msg_buffer, unacknowledged_msg_handler_info)    # adds unacknowledged_msg_handler_info to its own sorted_output_msg_buffer to keep track whether the msg is received or not through acknowledgement 
        add_to_thread_buffer(buffer_mngr.msg_buffer, string_msg)                             # Sends registration msg by adding to the buffer_mngr's buffer
        buffer_mngr.msg_buffer.put(string_msg)
     
     
     
    # initializes the handler_vector_table by mapping handler nos with the names
    def initialize_handler_vector_table(self):
        self.handler_vector_table = {'0': self.read_and_send_sensor_data}
    
    
    # Function: Inserts a msg handler info for each sensor which indicates the time at which
    # new reading will be produced by that sensor. 
    # Buffer is sorted in the ascending order of time so that while searching whether any msg has expired or not the whole buffer won't be scanned
    def initialize_sorted_output_msg_buffer(self): 
        """
        for sensor, info in sensors_info_dict.iteritems():
            self.logger.debug (info["start_time"])
            if (info["start_time"] and info["time_interval"]):
                # simply append to the end, then at the end sort the list
                next_schduld_time = add_time(info["start_time"], info["time_interval"])
                unacknowledged_msg_handler_info = [0, next_schduld_time, None, 4, 0]
                self.event_buffer.append(unacknowledged_msg_handler_info)
        # TODO: improve this
        # TODO: http://stackoverflow.com/input_bufferuestions/10695139/sort-a-list-of-tuples-by-2nd-item-integer-value
        # TODO: insert based on real time
        sorted(self.event_buffer,key=lambda x: x[1])
        self.logger.debug("Initialized unacknowledged_msg_handler_info list:"+str(self.event_buffer))       
        """
        self.logger.debug("Output buffer initialized.")
       
       
    """
    def extract_date(next_schduld_time):
        pass
        
    # Assigns sensor_controller's buffer's address and main_thread's buffer's address to the local variables           
    def get_buffer_instances(self, buffer, input_buffer):
        self.buffer = buffer
        self.input_buffer = input_buffer
    """
    
    
    # To get parameters of the sensor   
    def get_params(self, msg):
        self.logger.debug("Msg from NC to sensor sent to get params: " + msg)
    
    
    # Runs forever    
    def run(self):        
        global main_thread																		   # to access its input_buffer to send any internal msg
        global buffer_mngr																   # to access its input_buffer to send any internal msg
        self.logger.debug("Starting " + self.thread_name)
        
        while True:
            self.logger.debug ("sensor thread looping")
            time.sleep(20)
            """
            # Checks if any unprocessed msg is in the input buffer
            if self.input_buffer.not_empty:
                item = self.input_buffer.get()
                # internal_msg_header can be:
                #   1. received_external_msg
                #   2. received_internal_msg
                #   3. send
                internal_msg_header, msg = extract_header_and_msg(item)
                msg_type = extract_msg_type(msg)
                
                #  Ignore these 6 lines Waits for the registration to get complete and then starts sending the msgs to buffer_mngr's buffer
                #  Adds "send_external_msg" header to the front of the msg so the original_msg will take the form: "send_external_msg"+original_msg
                #  TODO: Remove the send type as it will directly go to the buffer
                if internal_msg_header == "send_external_msg":
                    start_communication_with_nc_event.wait()                                
                    buffer_mngr.msg_buffer.put(msg)
                
                
                if internal_msg_header == "received_external_msg":
                    process_external_msg(msg)                                               	# processes msgs obtained from NC/GNs
                    
                # Can be ack or command, command reply from some thread
                elif internal_msg_header == "received_internal_msg":
                    process_internal_msg(msg)                                               	# processes msgs obtained from sensor/communicator threads
                
                elif internal_msg_header == "send_external_msg":
                    if start_communication_with_nc_event.isSet():
                        # send to buffer_mngr's msg_buffer
                        buffer_mngr.msg_buffer.put(msg)
                    else:
                        # push at the end of input_buffer
                        sensor_controller.input_buffer.put(msg)
                        
                        self.input_buffer.task_done()
            
            # Checks if any unacknowledged msg has timed out / event has triggered (event is considered to have triggered when the expiration_time is reached)
            # Removes the msg from the list and calls the corresponding handler
            else:
                self.logger.debug ("checking for unacknowledged expired msgs")
                #timed_out_msg_info_list = get_timed_out_msgs()                         		# gets a list of msg_info in ascending order of time which contains timed out unacknowledged msgs/msgs like "get threads' status" expire
                #for msg_info in timed_out_msg_info_list:
                #    self.handler_vector_table[msg_info[3]](None)                             # calls the corresponding handler whose no is stored in msg_info, by accessing handler_vector_table, None is passed in place of msg acknowledgement 
            """
            
            
            
            
# main_thread (object of main_class): Spawns other threads and processes any messages intended for itself              
class main_class():
    
    logger = set_logging_level("main_thread")
    
    def __init__(self, thread_name, nc_IP, nc_port):
        
        self.thread_name = thread_name                 # used by logging module for printing messages related to this thread
        self.reg_msg_handler_no = 0
        self.update_handler_no = 1
        self.status_handler_no = 2
        self.input_buffer = Queue.Queue()              # stores messages sent by buffer_mngr_class, sensor_controller_class
        self.sorted_output_msg_buffer = []             # stores messages sent to any node/communicator/sensor threads which are unacknowledged and also any events like "get threads' status" which should occur periodically
        # handler_vector_table stores the mapping of the handler_no and handler, handler_no will be used to get function name using handler_no when the expiration_time of any msg (like "get threads' status") in sorted output msg buffer is reached 
        # or unacknowledged msg times out or is acknowledged
        self.handler_vector_table = {}                 
        self.nc_ip = nc_ip                             # IP of NC to send to the external_communicator_class
        self.nc_port  = nc_port                        # port no. of NC to send to the external_communicator_class         
        self.initialize_sorted_output_msg_buffer()     # inserts the msg which will inform when to ask for the threads' status
        self.logger.debug("Thread "+self.thread_name+" Initialized.")
    
    # initializes the handler_vector_table by mapping handler nos with the names
    def initialize_handler_vector_table(self):
        
        # initialize handler_vector_table by mapping handler no with handler name
        self.handler_vector_table[self.reg_msg_handler_no] = reg_msg_handler 
        self.handler_vector_table[update_handler_no] = update_cmd_handler
        self.handler_vector_table[status_handler_no] = status_cmd_handler
    
    # Sends "status" msg to sensor_controller_class, buffer_mngr_class by apunacknowledged "received_internal_msg/internal_seq/thread_name="main_thread" before "status" and waits by looping on the sorted_output_msg_buffer
    # till it receives reply from both the threads or it times out. If it times out then tries to restart that specific thread and logs this event as threads crashed= "sensor_controller_class/buffer_mngr_class"
    # Once it gets statuses from both then it stores both the statuses plus its own in a file. After collecting status info it adds the same event to the sorted_output_msg_buffer to occur after specific time
    # This is called periodically
    def status_cmd_handler(status):
        pass
        
    # TODO: Dnt know what it will do
    def update_cmd_handler(msg):
        pass
    
    # msg can be registration ack obtained from NC or if msg times out then None
    # If ack is obtained then sets the start_communication_with_nc_event evevt tso that further communication of sensors with NC can start
    # If msg times out then sends the msg="NC Alive?" to NC by adding to buffer_mngr's buffer
    # and when receives msg="status_NC=working" from buffer_mngr then resends the registration msg by calling send_GN_registration_request 
    def reg_msg_handler(self, cmd, reply):
        self.logger.debug("Registration msg handler called")
        if reply:
            reply_content = reply.payload
            if reply_content == "Registration Done":
                start_communication_with_nc_event.set()
                self.create_config_file()
            elif reply_content == "ACK":                                                         # immediate ACK is obtained
                # insert another packet which times out if final ACK = "Action taken" is not obtained
                expiration_time = add_to_current_time(60)                                        # no of seconds to be added to the current time to set the timeout 
                unacknowledged_msg_handler_info = [seq_no, expiration_time, cmd, self.reg_msg_handler_no]   # contains seq_no, expiration_time, registration msg, handler no corresponding to the handler which will be called when this msg times out or acknowledged
                add_to_sorted_output_buffer(self.sorted_output_msg_buffer, unacknowledged_msg_handler_info)    # adds unacknowledged_msg_handler_info to its own sorted_output_msg_buffer to keep track whether the msg is received or not through acknowledgement 
                self.logger.debug("1st ACK obtained and waiting for 2nd ACK")
                
        else:
            # TODO: handle failure
            self.logger.debug("Registration timeout: ABORTING................................................................................................................................................")
            sys.exit(-1)
        
        
    
    # TODO: Add the "status" msg to the queue so that periodically status is collected by the main_thread when the expiration_time of "status" msg is reached
    def initialize_sorted_output_msg_buffer(self):
        pass
   
   
    # Prepares registration msg and adds to buffer_mngr_class's buffer for sending it to NC
    # temporary hack: pass msg obtained from initial sensors readings directly
    # by appending seq_no, msg_type
    def send_GN_registration_request(self):
        global buffer_mngr                                                   				  # object of buffer_mngr_class, in this func its used to access its msg_buffer to add the registration message
        """
        msg_type = 0
        value_names = Record.arrayToStr(sensors_info[2], 2)
        units = Record.arrayToStr(sensors_info[3], 2)
        values = Record.arrayToStr(sensors_info[4], 2)
        types = Record.arrayToStr(sensors_info[5], 2)
        node_ids = Record.arrayToStr(sensors_info[6], 2)
        array = [msg_type, sensors_info]
    
        Record.arrayToStr(array, 0)
        string_msg = Record._converToStr(array)
        string_msg.add_header(string_msg, "send_external_msg")
        """
        expiration_time = add_to_current_time(10)                                                     # 10 seconds timeout
        # TODO: prepare_msg
        string_msg = "GN_Reg[0]"                                                               # prepare_msg will be called to get the sensors_info in string form with delimiters
        # TODO: use semaphores/lock
        seq_no = gen_next_seq_no_to_nc()                                                          # get seq_no to append in the front of the registration message
        # TODO: unlock
        self.logger.debug("Seq no generated: "+str(seq_no))
        # string_msg = add_header2(string_msg, msg_type)                                          # adds header msg_type (can be 0/1/2/3) in front of the registration message and returns whole message in string form by adding delimiter
        # string_msg = add_header1(string_msg, seq_no)                                   # adds header seq_no in front of the registration message and returns whole message in string form by adding delimiter
        string_msg = "1[2]3[2]gn1[2]" + str(datetime.datetime.now())+"[2]"+str(seq_no) + "[2]-1[1]" + string_msg
        self.logger.debug("Reg Msg prepared: "+string_msg)
        string_msg = buffered_msg("send_external_msg" ,string_msg)                   # adds header "send_external_msg" in front of the registration message and returns whole message in string form by adding delimiter
        unacknowledged_msg_handler_info = [seq_no, expiration_time, string_msg, self.reg_msg_handler_no]   # contains seq_no, expiration_time, registration msg, handler no corresponding to the handler which will be called when this msg times out or acknowledged
        add_to_sorted_output_buffer(self.sorted_output_msg_buffer, unacknowledged_msg_handler_info)    # adds unacknowledged_msg_handler_info to its own sorted_output_msg_buffer to keep track whether the msg is received or not through acknowledgement 
        add_to_unacknowledged_msg_thread_mapping(seq_no, self)                         # adds (seq_no, self) to the unacknowledged_msg_thread_mapping to inform the communicator about the unacknowledged msg
        add_to_thread_buffer(buffer_mngr.msg_buffer, string_msg)                             # Sends registration msg by adding to the buffer_mngr's buffer
        self.logger.debug ("Reg msg sent:"+str(string_msg))


    # TODO
    # Function: Checks by reading the log file whether registration has been done or not. If registration is done then it updates the seq_no to the seq_no of the last msg saved in the log file 
    # Returns: True if registration done else false
    def check_registration_status(self):
        return False
    
    
    # TODO
    # Function: Sends "Ready" packet to NC with the (last seq_no of previous communication with NC + 1) and waits for its ACK. When it gets the ACK then it sets the event "start_communication_with_nc_event" and then normal communication resumes 
    # Returns: None
    def send_ready_notification(self):
        pass
    

    # Runs forever
    def run(self):
        global buffer_mngr                                                  			  # used to access its msg_buffer to send any msg
        global sensor_controller																		  # to access its input_buffer to send any internal msg	
        try:
            self.logger.debug("Starting " + self.thread_name)
            # Starts the sensors
            # Create sensors_info_dict
            # sensors_info = get_sensors_info()
            # self.logger.debug("Initialization info from sensors:")
            # self.logger.debug(str(sensors_info)+ "\n")
            # sensors_info = create_sensors_info_dict(sensors_info)
            # Spawns 2 threads
            sensor_controller = sensor_controller_class("sensor_controller")                                             # handles sensors related messages
            buffer_mngr = buffer_mngr_class("buffer_mngr", self.nc_ip, self.nc_port) # handles communication of the GN with NC/other GNs
            # Starts sensor Thread
            sensor_controller.start()
            # Starts communicator Thread
            buffer_mngr.start()
            if self.check_registration_status():
                # Registration already done so just send msg to NC saying that I am up
                self.send_ready_notification()
            else:
                self.send_GN_registration_request()                                             # sends registration message to the NC to become visible in the outer world
            self.logger.debug("Thread starts waiting for msgs.")
            # start_communication_with_nc_event.wait()                                                              # do nothing until registration is successful, this event is set by reg_msg_handler when reg ack is received
            # Loops till a message is received in the input buffer or any unacknowledged msg times out/event like "get threads' status" triggers when its expiration_time is reached        
            # TODO: Add the get status msg in intialize_output buffer or create a separate thread for it
            while True:
                #self.logger.debug("Main thread looping")
                #time.sleep(20)
                # Checks if any unprocessed msg in the input buffer
                if not self.input_buffer.empty():
                    self.logger.debug("buffer not empty")
                    item = self.input_buffer.get()
                    self.logger.debug("item in buffer:"+str(item))
                    internal_msg_header = item.internal_msg_header
                    # internal_msg_header can be:
                    #   1. received_external_msg
                    #   2. received_internal_msg
                        
                    if internal_msg_header == "received_external_msg":
                        process_external_msg(item)                                               # processes msgs obtained from NC/GNs
                        
                        """
                        # ignore these 5 lines
                        msg_type, msg = extract_msg_type_and_msg(item)
                        if msg_type == "0":
                            self.logger.debug("Registration Successful.............") 
                            del_event(seq_no, self.event_buffer)
                        """
                    
                    # Can be ack or reply from some thread
                    elif internal_msg_header == "received_internal_msg":
                        process_internal_msg(item)                                               # processes msgs obtained from sensor/communicator threads
                    self.input_buffer.task_done()
                
                # Checks if any unacknowledged msg has timed out / event has triggered (event is considered to have triggered when the expiration_time is reached)
                # Removes the msg from the list and calls the corresponding handler 
                else:
                    """
                    self.logger.debug ("checking for unacknowledged expired msgs")
                    timed_out_msg_info_list = get_timed_out_msgs()                              # gets a list of msg_info in ascending order of time which contains timed out unacknowledged msgs/msgs like "get threads' status" expire
                    for msg_info in timed_out_msg_info_list:
                        self.handler_vector_table[msg_info[3]](None)                            # calls the corresponding handler whose no is stored in msg_info, by accessing handler_vector_table, None is passed in place of msg acknowledgement 
                    """
                    pass
                
        except KeyboardInterrupt:
            self.logger.debug("Ctrl+c caught")
            sys.exit()
    
    
    # Returns the msg by packing all params using delimiters and adding data at the end
    def prepare_msg(msg_type, seq_no, reply_id, data):
        # Call proper handlers by converting the data into arrays
        return "1[2]"+str(msg_type)+"[2]gn1[2]" + str(datetime.datetime.now())+"[2]"+str(seq_no) + "[2]"+str(reply_id)+"[1]" + data + "[0]"
    
        
    # Extracts the seq_no and checks in the output sorted msg queue if its a reply of some msg, 
    # if so then deletes that msg from the output sorted msg queue, takes required action after deleting by calling the msg handler and passing the reply to it
    # If its a new msg then sends to process_cmd for taking necessary action
    def process_external_msg(self, item):
        msg = item.msg
        if not start_communication_with_nc_event.isSet():
            # all msgs should be processed only after registration ACK is obtained
            if not is_registration_ack(msg):
                self.input_buffer.put(item)                                              # push the msg back in the queue as registration is not over
                return
        if msg.reply_id != -1:                                                                                  # its a reply
            if msg.payload != "ACK":
                # send ack for the msg received
                seq_no = gen_next_seq_no_to_nc()                                                                      # generates the next seq_no for the specific gn who is identified using gn_id
                msg = prepare_msg(2, seq_no, msg.seq_no, "ACK")
                item = buffered_msg("send_external_msg", msg)
                add_to_thread_buffer(buffer_mngr, item)                                  # adds to gn_msgs_buffer_mngr's msg_buffer so that it can send to NC through internal_communicator's object
            # get from the sorted_output_msg_buffer the corresponding unacknowledged_msg_info whose seq_no==reply_id of the received msg
            msg_info = get_msg_info_and_delete_from_output_buffer(self.sorted_output_msg_buffer, msg.reply_id)         # removes the msg_info from output sorted msg queue and returns it 
            handler[msg_info[3]](msg_info[2], msg)        # calls the handler whose no is stored in the msg_info at index 3 and passes the original msg and the reply received
        else:
            # a new command is received     
            self.process_cmd(msg)
     
     
    # decodes the msg (seq_no, msg_type, cmd, cmd_args) and maps it to the system specific command/action required
    def process_cmd(self, msg):
        if msg == "Update":
            #TODO 
            update_cmd_handler()
        elif msg == "Status":
            #TODO
            get_status()
       
    
    # checks by looking at seq_no and msg_type of original msg whether the received msg is registration ack or not_empty
    def is_registration_ack(msg):
        if msg.reply_id != -1 and msg.payload == "ACK":                             # received msg is a reply and its an ACK
            # get from the sorted_output_msg_buffer the corresponding unacknowledged_msg_info whose seq_no==reply_id of the received msg
            msg_info = get_msg_info_and_delete_from_output_buffer(self.sorted_output_msg_buffer, msg.reply_id) # removes the msg_info from output sorted msg queue and returns it 
            if msg_info[2].msg_type == 3:                                                                      # the received msg is an ACK of the sent registration msg
                return True
        return False
    
    
    # msg format of received_internal_msgs: internal_seq_no, thread_name, cmd (string), cmd_reply (string) Ex: seq_no, sensor_controller_class, "status", "actual status of all sensors" 
    # main_thread can only receive replies to the commands sent by it to other threads 
    # decodes the msg and then removes the corresponding msg entry from the output sorted msg queue based on internal_seq_no and calls the handler by passing the msg
    def process_internal_msg(self, msg):
        internal_seq_no = extract_seq_no(msg)
        msg_info = get_msg_info_and_delete_from_output_buffer(self.sorted_output_msg_buffer, internal_seq_no)         		# removes the msg_info from output sorted msg queue and returns it                                  
        handler[msg_info[3]](msg)                                                                                     		# calls the handler whose no is stored in the msg_info to process the msg
       
       
       

# Program starts execution by calling main_class's object
# handler for logging msgs 
logger = set_logging_level("Global Scope:")
main_thread = main_class("main_thread", nc_ip, nc_port)     
main_thread.run()
