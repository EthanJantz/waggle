NC files

__init__.py
Everything starts here.It instantiates the msg_processor class and starts it.

nc_msg_processor_class.py
1. Stores system's info
1. Instantiates and starts buffer_mngr and nc_server
2. Processes registration and data msgs obtained from GNs and sends the registration msg for cloud and ACKs for GNs

nc_buffer_mngr_class.py
1. Manages the bfr_for_sent_msgs, bfr_for_sent_responses, bfr_for_in_to_out_msgs and bfr_for_out_to_in_msgs
2. All the communication with the socket is managed by this thread. Sends all msgs coming from msg_processor to sockets/cloud (using send_msg_to_cloud) and vice versa.
3. Handles encoding and decoding of msgs obtained from GNs
4. Implements the lock step protocol and hence responsible for deciding whether a new msg should be accepted or discarded
5. Handles simple ACKs (which might be received from GNs in future)

nc_internal_communicator_class.py
1. Is an asynchat object handling communication with a GN

nc_server_class.py: Change the IP in self.bind() to bind the server to the apt NC IP address (if there are two IP addresses for NC).
1. Server listening for GN's requests

nc_global_definition_section.py
1. Defines global variables, events if any, functions common to most threads

config_file_functions.py
1. Contains only initialize_config_file function

get_node_info.py
1. Runs bash scripts to collect system's info required for registration.

global_imports.py
1. Import statements of the packages used by most of the threads

Useful scripts to collect which all global variables from global_definition file should be imported for each module:
filter_needed_vars.py
filtered_vars

Python packages:
asynchat.py - Comparatively better version of asynchat, to run this version always include the path where this file is present in PYTHONPATH
configobj.py - Provides ConfigOBj used to store registration info

########################################################################################
Protocol in brief
########################################################################################

-------------last and ackd subseq_nos

1. last_nc_subseq_no/last_gn_subseq_nos are used as unique sequence nos during one session.

2. ackd_nc_subseq_no/ackd_gn_subseq_nos are used to let other party know that which is the 
last_subseq_no till which all ACKs have been obtained. This further helps in detecting the
duplicate msgs or detecting the old msgs circulating unnecessarily in case of loss
of network connectivity.

3. Every new msg is validated based on the last and ackd subseq_nos of the previous msg and core part 
   is explained in in_expected_subseq_range function.

4. When first time the msg arrives then based on a new session id and certain other conditions
it is accepted. Conditions are written as comments in new_msg function.

5. ackd and last subseq nos of the sending party are updated whenever a new msg from that party arrives.

6. ackd subseq_no of itself is updated when 1) an ACK is obtained from the other party for some pending msg in bfr_for_sent_msgs or 
   2) when the node itself sends a new msg to someone.
   So, for NC as in current scenario it never sends any new msg, so ackd and last subseq_nos will always be the
   same and ackd is always set to last_nc_subseq_no. 
   Its explained in the code in gen_nc_ackd_subseq_no and get_and_del_saved_msg where updation of ackd_subseq_no takes place. 
   
   last_subseq_no is always incremented by 1 when the node sends a new msg to a specific node.
   
-------------MSGs

    A new *msg* (not ACK) is only sent by a GN/NC when the corresponding bfr_for_sent_msgs is not full, full is determined
      by the window size. Else it puts the msg back in the queue. buffer_mngr thread does this check.
    
    Every sent msg is buffered in the bfr_for_sent_msgs till an ACK for that msg is obtained. 
   
    Whenever a msg times out it is resent and so at that time no check is made as we are not adding anything extra to the bfr_for_sent_msgs.
    
    When a duplicate msg arrives, NC/GN resends its ACK without processing the msg again.

------------ACKs

    When a response/ACK is sent we don't check anything as in this case also we are not adding anything extra to the bfr_for_sent_msgs.
    
    Every sent ACK is buffered in the bfr_for_sent_responses till the apt msg having ackd_subseq_no >= reply_ids of the buffered ACKs is obtained 
    from the other party. Comments are written to explain the scenarios in discard_ackd_responses function.
    
    When a duplicate ACK arrives, it is discarded as no corresponding msg is present in the 
    waiting buffer.

   
--- Currently the protocol is designed to work with same window size on both the ends
    but can be easily converted to different sizes.

########################################################################################
BUGS Fixed
########################################################################################

1. In nc_buffer_mngr_class: init_socket() for mapping gn's socket to its inst_id was called after checking whether the msg is new or not
which was causing probs when an old msg whose ACK was already buffered by the NC was being sent by the GN after the first time due to asynchat error
whenever the two parties got disconnected. As the NC in new_msg resent the response to the old closed socket of the GN, it was never reaching the GN
and so GN as the new socket was not mapped before resending the response. This was causing the error. So now related changes to the socket function 
are made and its placed before validating the incoming msg.

2. Also, changes are made to the protocol related to the acknowledged subseq_no.

