#######################
NC files
#######################


run_nc.py
Everything starts here.It instantiates the msg_processor class and starts it.

nc_msg_processor_class.py
1. Stores system's info
1. Instantiates and starts buffer_mngr and nc_server
2. Processes registration and data msgs obtained from GNs and sends the registration msg for cloud and ACKs for GNs

nc_buffer_mngr_class.py
1. All the communication with the socket is managed by this thread. Sends all msgs/ACKs coming from msg_processor to sockets/cloud (using send_msg_to_cloud) and vice versa.
2. Handles encoding and decoding of msgs obtained from GNs
3. Implements the lock step protocol and hence responsible for deciding whether a new msg should be accepted or discarded

nc_internal_communicator_class.py
1. Is an asynchat object handling communication with a GN

nc_server_class.py: Change the IP in self.bind() to bind the server to the apt NC IP address (if there are two IP addresses for NC).
1. Server listening for GN's requests and assigning new socket to each newly connected GN

nc_global_definition_section.py
1. Defines global variables, events if any, functions common to most threads

config_file_functions.py
1. Contains only initialize_config_file function

get_node_info.py
1. Runs bash scripts to collect system's info required for registration.

global_imports.py
1. Import statements of the packages used by most of the threads

inst_id
1. Stores instance_id of the node


Python packages:
asynchat.py - Comparatively better version of asynchat, to run this version always include the path where this file is present in PYTHONPATH
configobj.py - Provides ConfigOBj used to store registration info




########################################################################################
FLOW
########################################################################################
1. nc_server listens for GN's requests.
2. New GN's connection request received.
3. New socket (internal_communicator class's instance) created and assigned as socket for
   future communication with this GN. Continues to listen for other requests.
4. Newly connected GN sends registration msg.
5. Msg is checked for validity based on Lock-Step protocol.
6. If valid then its considered and processed and it is sent to the cloud and the ACK sent back
   to the GN.
7. Then NC will start receiving sensor msgs from GN. 
8. Each msg checked for validity, if valid then msg is forwarded to cloud and ACK is sent back. This repeats.


########################################################################################
Protocol in brief
########################################################################################

-------------highest and ackd subseq_nos

1. nc_highest_subseq_no/gn_highest_subseq_nos are used as unique sequence nos during one session.

2. nc_ackd_subseq_no/gn_ackd_subseq_nos are used to let other party know that which is the 
highest_subseq_no till which all ACKs have been obtained. This further helps in detecting the
duplicate msgs or detecting the old msgs circulating unnecessarily in case of loss
of network connectivity.

3. Every new msg is validated based on the highest and ackd subseq_nos of the previous msg and core part 
   is explained in in_expected_subseq_range function.

4. When first time the msg arrives then based on a new session id and certain other conditions
it is accepted. Conditions are written as comments in new_msg function.

########################
UPDATION OF highest_subseq_no and ackd_subseq_no:
########################

1. Sending party: ackd and highest subseq nos are updated whenever a new msg from that party arrives.

2. Itself : 

   1. ackd subseq_no updated when:

            -1) an ACK is obtained from the other party for some msg pending in sent_ncMsgBfr
            OR
            -2) when the node itself sends a reply to someone and it doesn't have any pending unacknowledged msgs.
            Its explained in the code in gen_nc_ackd_subseq_no where updation of ackd_subseq_no takes place. 
   
   2. highest_subseq_no is always incremented by 1 when the node sends a new msg to a specific node.
   
#######################   
     
-------------MSGs

    1. When a duplicate msg arrives, NC resends its ACK without processing the msg again.

------------ACKs

    1. When a response/ACK is sent we don't check anything as in this case we are not adding anything extra to the sent_ncMsgBfr.
    
    2. Every sent ACK is buffered in the sent_ncAckBfr till the apt msg having ackd_subseq_no >= reply_ids of the buffered ACKs is obtained 
    from the other party. Comments are written to explain the scenarios in discard_ackd_responses function.
 
#######################

MISC:
--- Currently the protocol is designed to work with same window size on both the ends
    but can be easily converted to different sizes. 
    
--- Latency of sending and receiving msgs depends a lot on the count parameter in asynchat socket in internal_communicator class,
    on the wait_time and sleep time of the threads and the frequency of receiving msgs.
    CPU Usage/Latency also increases due to logging stuff to file.
    
--- Either remove nc.cfg, NC's session_ids and GN's session_ids together else don't touch them as these files maintain the state at both the ends

########################################################################################
BUGS Fixed
########################################################################################

1. In nc_buffer_mngr_class: map_socket() for mapping gn's socket to its inst_id was called after checking whether the msg is new or not
which was causing probs when an old msg whose ACK was already buffered by the NC was being sent by the GN after the first time due to asynchat error
whenever the two parties got disconnected. As the NC in new_msg resent the response to the old closed socket of the GN, it was never reaching the GN
and so GN as the new socket was not mapped before resending the response. This was causing the error. So now related changes to the socket function 
are made and its placed before validating the incoming msg.

2. Also, changes are made to the protocol related to the acknowledged subseq_no.

3. Lock is implemented to access the shared data structure- gn_socket_list so that there may not be any race conditions in future.

4. Temporarily sequence_no is changed from bytes to int to avoid errors because of sequence nos containing delimiters



########################################################################################
NORMAL Exceptions/Errors due to asynchat/pika
########################################################################################

On NC Side:

Due to asynchat sometimes the same msg is sent twice and as a result you may get
error like:

1. Old msg with subseq_no:XXXX received whose ACK is not yet sent.


Due to pika:
Exception in send_msg_to_cloud




