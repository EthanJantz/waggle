
\section{From Power On to Application Execution}

A walkthrough of the boot process on embedded systems bind with techniques to improve fault-tolerance and enhance system security.


\subsection{High-level Picture}

\begin{enumerate}
 \item Power on
 \item Bootload
 \item Kernel
 \item initramfs (optional)
 \item init and other startup frameworks
 \item applications
\end{enumerate}

When we press the power-on button the hardware begins the execution of a predefined instruction sequence, conventionally stored at a ROM storage device. The only purpose of the ROM code is to make a jump to the start of the bootload sequence code. The bootloader sequence can be implemented using one or multiple binary objects; each one linking to the other through a software execution jump. The bootloader is responsible for initializing the basic devices that are required to execute the operating system. After the initialization a software jump is made to the operating system kernel. The kernel subsequently initializes the rest of the devices, the file system, and starts the execution of the \textit{init} process which executes the startup scripts. Finally, after all daemons and services are running, user application are started.

Following we give a more thorough explanation of the above step sequence. We should note here that the sequence for embedded systems is not the same as the one for general purpose systems; especially the steps from the power on to the kernel execution. We focus our description on the sequence of steps need on the Odroid board.

\subsubsection{Power On}

When the power on button is pressed the power supply system allows for currect to flow on the different devices of the board, subsequently each device is initialized on a default state and is ready for the next stage of execution. The processor then starts executing starting from a default value of the program counter (PC). The default value of the PC points to an address that an internal ROM memory is mapped. The internal ROM memory contains an initialization code that will continue with the boot process and pass the execution control to the bootloader. In the case of Odroid the ROM code searches for a level 1 boot binary first at the eMMC device and then on the sd Card, when found it performs a jump to the start of the level 1 bootloader (i.e. the code is loaded to the main memory and the program counter (PC) is initialized to the correct address).

As this portion is entierly implemented by the processor manufacturer we have no control on how to improve its reliability or security.

\subsubsection{Bootload}

\textbf{What a bootloader is}

As we focus on ARM embedded system and specifically the Odroid platform the choices of bootloaders are limited to the following three: U-Boot, barebox, and redboot. From the three U-Boot is the one that is more activelly developed and used. barebox is a fork of U-Boot that tries to follow closely the driver model and design concepts from the Linux kernel. \textbf{ADD ABOUT redboot}. From these three choices only U-Boot provides support for Odroid and is also the default bootloader provided by Hardkernel.

The bootloader sequence of Odroid is composed from 3 parts. The first level bootloader (BL1), the second level bootloader (BL2) and the U-Boot bootloader. The binary object of the 3 stages can reside on the eMMC memory of the board or on an sd card, in either case the placement is important as each stage expect the next stage to reside in a predefined location address of the storage (see Table \ref{tab:odroid-boot-placement}.

\begin{table}[h]
\begin{center}
 \begin{tabular}{| l | l | l | l |}
 \hline
 Binary & \multicolumn{2}{|c|}{Block offset} & partition type \\
 name   & SD & eMMC & (eMMC only) \\
 \hline
 \hline
 Bl1 & 1 & 0 & 1 (boot) \\
 \hline
 Bl2 & 31 & 30 & 1 (boot) \\
 \hline
 U-Boot & 63 & 62 & 1 (boot) \\
 \hline
 Tzsw & 2111 & 2110 & 1 (boot) \\
 \hline
 Uboot Env & 2500 & 2500 & 0 (user) \\
 \hline
 \end{tabular}
\caption{cite README.odroid}
\label{tab:odroid-boot-placement}
\end{center}
\end{table}

%%  -------------------------------------
%% |  Binary   | Block offset| part type |
%% |   name    | SD   | eMMC |(eMMC only)|
%%  -------------------------------------
%% | Bl1       | 1    | 0    |  1 (boot) |
%% | Bl2       | 31   | 30   |  1 (boot) |
%% | U-boot    | 63   | 62   |  1 (boot) |
%% | Tzsw      | 2111 | 2110 |  1 (boot) |
%% | Uboot Env | 2500 | 2500 |  0 (user) |
%%  -------------------------------------


The first level bootloader (BL1) is a propietary software developed and signed by Samsung, thus we have not control over it, and is essential for the operation of the board. BL1 is relatively small in size (15K)  and its main responsibility is to pass execution control to the signed second level bootloader.

The second level bootloader (BL2) is the \textit{secondary program loader} segment of the U-Boot source code. It is signed by Samsung for Hardkernel. In the doc/README.odroid file of U-Boot mainline code it is stated ``This version of U-BOOT doesn't implement SPL but it is required(BL2)''. BL2 is responsible for launching the main U-Boot binary.

U-Boot is the third and last stage of the bootloader process at Odroid. It is open source software and we can compile and run our custom version. It is responsible for finalizing the initialization of devices before starting the operating systems. It can also be signed by a private key, however, cooperation with Hardkernel would be required to make the transition from BL2 to U-Boot secure. \textbf{GIVE MORE GENERAL INFORMATION ABOUT U-BOOT: mention boot script file, uImage and FIT format}

The U-Boot project has created a packaging format for linux kernel binaries that can be used to support conditional booting of kernel binaries based on the integrity of a checksum. More specifically, the new packaging format, called uImage, appends a fixed size header to the begining of the kernel binary that contains general information of the kernel together with checksum of the binary. As previously stated U-Boot support a script-like language to be used on booting. The support for conditional statement and the validation of the checksum of a \textit{uImage} allows the implementation of a conditional boot scheme that boots a binary only if it passes a sanity check.

Further more the kernel boot process can become secure using the FIT packaging format. \textbf{THIS IS NOT WORKING YET}.

After the sanity and sign checks are passed U-Boot passes control of the execution to the Linux kernel.


Even though a security step is provided by the vendor this does not extend to a fully trusted computing platform as there is an unsecure transition between BL2 and U-Boot. This gap can be closed by requesting from Samsung to provide a BL2 that would enable the booting of a signed, by our key, version of U-Boot. However, this process is quite tedious and based entierly on Samsungs discration. For this reason it would be beneficial on the future to adopt more open platforms.

In terms of reliability U-Boot provides the conditional booting based on checksums and also supports a limited set of Power-On Self-Tests (POST) that can be run before executing the kernel. \textbf{MORE DETAILS ABOUT POSTs OF U-BOOT}

\textbf{Another step to improve fault-tolerance would be to make the Uboot Env be on top of a journaling file system (ext4) instead of FAT. This is not tested yet}

\subsubsection{Kernel}

The Linux kernel is responsible for providing an API to the available devices and starting the daemons and services required. It can be launched into an initramfs or directly in the rootfs.

Security: signed modules, signed file system

\subsubsection{initramfs, init \& other startup frameworks}

The initramfs: what is it?


During the starup of the daemons and services, the very first thing to check is if we are booting back from a crash. This would enable us to either correct possible corrupt state or restrict the system's capabilities to improve its stability.

This is done through a custom system configuration file and stress test applications. The configuration file provides a description about the resources of the system that we can use together with maximum values for them.

The stress suite provides applications that stress specific resources and log that process on a lockstep file that can be parsed after a possible crash to create a restiction about the resource.


Inside initramfs and before transitioning to the rootfs we can perform checks to verify the integrity of the file systems that reside in the sd card or the eMMC. This is the only stage we can do this as we need the partiotion unmounted.

cpusets: what do they support, what are the limitations, what do we need to change to overcome them.

Monit supports daemon start up, application monitoring, and application restart.

\subsubsection{User Applications}

