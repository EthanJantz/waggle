\section{In Detail}

In the previous section a brief summary of all the steps from power-on to user-level execution where given, in this one a more thorough explanation is attempted for each stage together with details regarding fault-tolerance and security. We should note here that the sequence on stages is not the same for embedded systems and general purpose systems; especially the steps from power-on to kernel execution. Also, our reference platform is going to be the OdroidU3 board, still, we will try and keep the description as generic as we can. 


\subsection{Power On}

When the start button is pressed the power supply system powers the different devices of the board, and through its state machine each device is initialized on a default state becoming ready for the next stage of execution. The processor then begins executing starting from a default value of the program counter (PC) \cite{Fundamentals_of_Booting_for_Embedded_Processors}. The default value of the PC points to an address that an internal ROM memory is mapped. The internal ROM memory contains an initialization code that defines the first stage of the bootloader stage and is responsible to pass the execution control to the second-stage bootloader. In the case of Odroid the ROM code searches for a second-stage bootloader first at the eMMC device and then on the sd Card; then it performs a jump to the start of the first on to be found (i.e. the code is loaded to the main memory and the program counter (PC) is initialized to the correct address). This process is platform specific and in the majority of the case the code and details are not open to the user, thus we have no control on how to improve its reliability or security.

\subsubsection{Fault-tolerance}

As the stage of power-on mainly consistes of hardware state transitions and limited proprietary code execution, the fault-tolerance techniques are restricted significantly. Each devices needs to be able to verify it can reach its default stage and the processor can make a sanity check on the first-stage of the bootloader code. All of the above need to be part of the initial design of the board and can not be changed/introduced from a user.

\subsubsection{Security}

In terms of security what is currently available is the requirement for a signed (by the processor vendor company) binary to continue to the bootloader stage. This feature even though it increases security it also significantly limits the choices for later.

\subsection{Bootloader}

The second stage is the bootloader, but before continuing to describe the bootloader stage in more details let us give first the definition of the stage. As bootloader stage we define the sequence of steps after power-on and before the operating system kernel is executed. This sequence can be split in at least two steps. In the first one the processor executes a vendor provided code to make the transition to the second-stage bootloader. The second stage is after the transition to the second-stage bootloader which can subsequently pass control to another bootloader process or execute the operating system's kernel.

As we focus on ARM embedded systems, and specifically on the Odroid platform, the choices of bootloaders are limited to the following three: \textit{U-Boot}\cite{uboot}, \textit{barebox}\cite{barebox}, and \textit{redboot}\cite{redboot}. From the three U-Boot is the one that is more actively developed and used, \textit{barebox} is a fork of U-Boot that tries to follow closely the driver model and design concepts of the Linux kernel, and \textit{redboot} is another bootloader option for ARM systems developed by eCos. From these three choices only U-Boot provides support for Odroid. Following, without loss of generality, we describe the steps on the bootloader stage in OdroidU3.

The bootloader stage of Odroid is composed from 4 parts. The iROM code, which is code that resides inside the SoC, the first-stage bootloader (BL1), which is proprietary code of Samsung, the second-stage bootloader (BL2), which is part of U-Boot code, and  U-Boot. The binary object of the 3 later stages can reside on the eMMC memory of the board or on an sd card, in either case the placement is important as each stage expect the next stage to reside in a predefined address location of the storage (see Table \ref{tab:odroid-boot-placement} for details). The processor first start execution of the iROM code which ``will attempt to read the boot media at the first 512 bytes of it. On those first 512 bytes BL1 should exist'' \cite{odroid:boot_details}.

\begin{table}[h]
\begin{center}
 \begin{tabular}{| l | l | l | l |}
 \hline
 Binary & \multicolumn{2}{|c|}{Block offset} & partition type \\
 name   & SD & eMMC & (eMMC only) \\
 \hline
 \hline
 Bl1 & 1 & 0 & 1 (boot) \\
 \hline
 Bl2 & 31 & 30 & 1 (boot) \\
 \hline
 U-Boot & 63 & 62 & 1 (boot) \\
 \hline
 Tzsw & 2111 & 2110 & 1 (boot) \\
 \hline
 Uboot Env & 2500 & 2500 & 0 (user) \\
 \hline
 \end{tabular}
\caption{cite README.odroid}
\label{tab:odroid-boot-placement}
\end{center}
\end{table}

%%  -------------------------------------
%% |  Binary   | Block offset| part type |
%% |   name    | SD   | eMMC |(eMMC only)|
%%  -------------------------------------
%% | Bl1       | 1    | 0    |  1 (boot) |
%% | Bl2       | 31   | 30   |  1 (boot) |
%% | U-boot    | 63   | 62   |  1 (boot) |
%% | Tzsw      | 2111 | 2110 |  1 (boot) |
%% | Uboot Env | 2500 | 2500 |  0 (user) |
%%  -------------------------------------

The iROM code is microcode designed by Samsung and is embedded in the SoC. Its only purpose is to pass execution control to a verified version of BL1.

The first-stage bootloader (BL1) is a proprietary software developed and signed by Samsung, thus we have no control over it, and is essential for the operation of the board. BL1 is relatively small in size (15K)  and its main responsibility is to pass execution control to the second-stage bootloader.

The second-stage bootloader (BL2) is the \textit{secondary program loader} (SPL) segment of the U-Boot source code. It is signed by Samsung for Hardkernel. In the \textit{doc/README.odroid} file of U-Boot mainline code it is stated that ``This version of U-BOOT doesn't implement SPL but it is required(BL2)'', thus even though it is not essential it is required in order to execute the main U-Boot logic.

U-Boot is the forth and last stage of the bootloader process at Odroid \endnote{This is not completely accurate as we can possible execute more stage before launching the operating system}. It is open source software and we can compile and run our custom version. It is responsible for finalizing the initialization of devices before starting the operating systems.

The installation of the 3 binaries on an sd card is straight forward and one can use the \textit{sd\_fusing.sh} script and files from \cite{sd_fusing}. Before flushing the bootloader binaries the sdcard or eMMC should be initialized in an appropriate state (file systems, empty space for bootloader binaries); a patched version of the mkcard script can be used for that (see Appendix \ref{appendix:mkcard}).

\textbf{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA}

U-Boot is a quite powerful bootloader, among other it provides support for multiple processors, file systems and boot protocols. The start of the operating system is described in a script file (boot.scr) that is placed on the ``U-Boot Environment'' partition. The parser of the script file is based on the \textit{sh} shell, allowing variable setting, conditional statements, together with u-boot specific commands. An novelty of U-Boot is the introduction of two new packaging methods for the linux kernel: uImage and flat image tree (FIT).

The uImage format \cite{uImage-fit} ``allows more flexibility in handling images of various types (kernel, ramdisk, etc.), it also enhances integrity protection of images with sha1 and md5 checksums''. Essential the uImage is generated by appending a fixed size header to the beginning of the linux kernel binary. The header contains general information of the kernel, such as cpu architecture and name of operating system, together with two checksums; one for the image header and one for the image data.

The FIT format \cite{uImage-fit} extends the flexibility of uImage by providing stronger checksum algorithms, multiple configuration combinations in a single file, and trusted configuration through hash signing

In the following two subsection we will give a description of the fault-tolerance and security features available on U-Boot, and how to combine other features to implement new.

\subsubsection{Fault Tolerance}

In terms of fault-tolerance and reliability in Odroid we can only work with features provided by U-Boot which are limited by default. Also, the existense of the 2 stages before U-Boot and the fact that they are closed actually degrades the reliability of the system. The more steps we have to go through the more likely a failure may appear and we have no way to augment the closed source code to imporve fault-tolerance.

By default U-Boot provides two fault-tolerance features, the power-on self-tests (POST) which can be enabled (when available) at compile time - however, any found error stays unhandled \textbf{NOT SURE IF IT WORKS FOR ODROID}- , and the second feature is the sanity check perfrormed when using a kernel that is packaged using the uImage format.

On top of these two features, we can combine existing tools to improve further the fault-tolerance of the system. Using the conditional statements of the parser a conditional boot scheme can be implemented based on sanity check of uImage checksums \endnote{The latest version of U-Boot supports only FIT images by default, define CONFIG\_IMAGE\_FORMAT\_LEGACY on the board configuration file to enable support of uImage}; the boot script will traverse through a number of uImage files and boot a binary only if it passes the sanity check. An example implementation of such a script is given below:

%{\tt \small
%\begin{verbatim}
\begin{lstlisting}
setenv kerneladdr 0x40007FC0
setenv bootargs "console=tty1 console=ttySAC1,115200n8 root=/dev/mmcblk0p2 rootwait rw mem=2047M"

setenv bootkernel "if test -e ${dev_type} ${dev_num} ${kernelname}; then; fatload ${dev_type} ${dev_num}:${dev_part} ${kerneladdr} ${kernelname}; if iminfo ${kerneladdr}; then; bootm ${kerneladdr}; fi; fi; "

### Boot mmc device 0 partition 1
setenv dev_type "mmc"
setenv dev_num "0"
setenv dev_part "1"

setenv kernelname uImage.1
run bootkernel

setenv kernelname uImage.2
run bootkernel

echo "Both kernels are corrupt"
\end{lstlisting}
%\end{verbatim}
%}

Another possible way to improve the fault-tolerance of the device would be to use a journaling file system (like ext4) for the UBoot Env partition \endnote{can be enabled during compilation using CONFIG\_CMD\_EXT4 and CONFIG\_CMD\_EXT4\_WRITE}; instead of the default FAT32 one.

Furthermore, the POST functions can be extended to expose detected failures in environment variables so that the boot process can handle them using custom extensions.

\subsubsection{Security}

In terms of security the bootloader process of Odroid enables by default certain security measures however it is not completely closed, which essentially, almost, nullifies the effect of the deployed measures. More specifically, the problem lies on the transition from BL2 to U-Boot which is not secure, that is, the U-Boot image is not required to be signed. Closing this hole is not going to be trivial as it would require the collaboration with Hardkernel so that either they sign a custom U-Boot image or that they allow a custom key pair to be embedded on the BL2 version they provide.

After resolving the problem with using a trusted bootloader binary the next security concern is the use of a trusted boot configuration, this can be supported from U-Boot using the FIT packaging format. As previously mentioned the FIT format supports the signing of a linux kernel image and device tree using assymetric encryption. \underline{There has been an attempt by us to use the signed FIT configuration but unsuccesfully}. An example FIT configuration file follows:

\textbf{INSERT FIR CONFIGURATION FILE}

Details on how to enable booting using FIT images can be found at \cite{uImage-fit}.

\subsection{Kernel}

The next step after the bootloader is the kernel execution. After the sanity and sign checks are passed U-Boot makes a software jump to the entry address of the operating system (Linux).

The kernel is responsible for providing an API to the available devices and starting the daemons and services required. It can be launched into an initial ram file system (initramfs) or directly in the root file system partition (rootfs).

\subsubsection{Fault Tolerance}

As the kernel can be compared to the brain of a system a failure in part of its code often results in a crash of the system. Even if the crash is not immediate the architectural state can not be fully trusted. Still, we can save the coredump of the kernel so it can be analyzed in a subsequent boot. \underline{I am not sure this is always possible}.

Nevertheless, a crash in a kernel module is not always fatal, and the kernel can attempt to clear the state after the error and either isolate the module or try restarting it \underline{make sure this is working}.

\subsubsection{Security}

In terms of security the kernel supports by default, through the file system, file access restrictions and different user/group privileges, and execution isolation inbetween processes.

Furthermore, the Linux kernel provides two frameworks to improve the security of the system: signed modules load, and signed files.

The first one, signed modules load, is the most straight forward to enable and forces the kernel to only load modules that are signed by a specific private key. To enable this feature it is required to have a key pair (X.509 \cite{wiki:x509}) and then use menuconfig to enable the different modules on the kernel as seen below \cite{gentoo:signed_module}:

{\tt
\tiny
\begin{verbatim}
[*] Enable loadable module support  --->
  [*]   Module signature verification
  [*]     Require modules to be validly signed
  Which hash algorithm should modules be signed with? (Sign modules with SHA-512)  --->
    ( ) Sign modules with SHA-1
    ( ) Sign modules with SHA-224
    ( ) Sign modules with SHA-256
    ( ) Sign modules with SHA-384
    (X) Sign modules with SHA-512
\end{verbatim}
}

A detailed example on how to enable signed modules support on the kernel can be found at \cite{gentoo:signed_module}.


The second feature, signed files, is part of the \textit{Linux Integrity Subsystem} and is implemented by extending the i-nodes of the file system with a signed hash value, thus whenever an access request is performed on the file the hash is verified and if it differs permission is denied. For more information about how to configure signed files (IMA/EVM) see \cite{gentoo:ima,gentoo:evm,linux:ima}.


\subsection{initramfs, init \& other startup frameworks}
\label{sec:init}

After the kernel starts executing the next step is the execution of the \textit{init} process \endnote{for what the init process is see \cite{wiki:init}}, either inside an initramfs \endnote{ initramfs is an archive of a minimal file system loaded and operated into memory during the Linux startup process. It is used to complete a number of tasks before switching to the real root file system} or directly from the root file system.

By default the init process does not provide any fault-tolerance or security other than the features provided by the operating system and file system (file permissions, IMA). However, we can implement custom schemes to improve system reliability and security.

\subsubsection{Fault Tolerance}

To improve the fault tolerance of a system the first step is to detect an improper shutdown. This can be performed during the starup of the daemons and services and it would enable us to either correct possible corrupt state or restrict the system's capabilities to improve its stability. A simple way to detect an improper shutdown is the existence of a file that is generated at startup and is removed on proper shutdown. 

After detecting an improper shutdown we need to investigate the reasons behind it. This can be done through parsing log files of activity before the crash. Another way is to attempt to artificialy reproduce the cause using custom applications (stress testing), while stressing the board we are logging each step so that we can identify the point of failure. By checking for the existens and interpretetion of the stress-test log file at startup we can generate a system configuration that sets maximum utilization on resources to improve system stability. An example of such constrain is the number of active CPUs. The Linux kernel provides an API to create sets of cpus (cpuset \underline{add citation}, see Appendix \ref{appendix:cpuset}) and restrict execution of applications inside the set.

Another important process to improve fault-tolerance in systems is the periodic check of the file system, especially after an improper shutdown. However, checking a file system while mounted creates inaccuraccies, for this reason the most appropriate time to do file system checks is when executing from the initramfs before any partition is mounted.

Finally, to increase availability and survivability we can monitor the deamon and services and perform restarts when crashes occurre or clean after them. An effective tool for this is \textit{monit} \cite{monit} which supports daemon start up, application monitoring, application restart, checksum of files, etc.


\subsubsection{Security}

Configure services to improve security. sshd, iptables, port knocking.


\subsection{User Applications}

Each application for itself... need to have functions/scripts that clean after a crash and log errors.

Designed with security considerations from the start.
