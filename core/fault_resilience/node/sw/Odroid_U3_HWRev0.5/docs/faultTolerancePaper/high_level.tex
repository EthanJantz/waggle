
\section{From Power On to Application Execution: A High-Level Picture}

In this section we present a high level walkthrough of the power-on to user-level execution on embedded systems. The procedure can be split in 5 distinct stages that would be later discussed in depth. The 5 stages are:

\begin{enumerate}
 \item power-on
 \item bootloader
 \item kernel
 \item initramfs (optional), init and other startup frameworks
 \item user-level applications
\end{enumerate}

The beginning of the process is the press of the start button and the platform's devices powered on (1). By design each device when powered-on is initialized to a default stable state, after the stable state is reached the processor makes a hardware jump to a predefined address and begins the execution of an instruction sequence, conventionally provided by the processor vendor and stored in a ROM storage device. This ROM code can be considered the first step of the bootloader stage (2), and its only purpose is to bring into memory the next step of the bootloader stage that provides more functionality. The bootloader sequence can be implemented in one or multiple stages; each one linking to the other through a software execution jump. The bootloader stage is responsible for initializing the basic devices that are required to start the operating system. Thus, after the initialization of the devices by the bootloader a software jump is made to the operating system's kernel (3). The kernel subsequently initializes the rest of the devices, the file system, interupts, etc, and executes the \textit{init} process (4) which is responsible for starting the rest of the services and startup scripts (the kernel can execute the init process inside an initramfs or a real partition, the differences of the two will be discussed in detail at section \ref{sec:init}). Finally, after all daemons and services are running, user-level processes are started (5).


